1、
对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。
但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。
实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力


2、线程的状态：
新建，就绪，运行，阻塞，销毁

新建 	 →  		就绪 
		 ↑		    ↓
		阻塞       ←	     运行     →   销毁	
		
new Thread()实例化后，就是新建状态
执行start(),就会进入就绪状态，不一定直接运行（执行线程中run方法的代码）
一般，系统会存在多个线程处于就绪状态，彼此竞争cpu时间，获得cpu时间的线程才会处于运行状态
jvm中的线程调度程序(thread scheduler)来调度，cpu运行哪一个就绪的线程。

线程优先级：t1.setPriority(10),范围1-10，默认5，优先级值越大，在就绪状态被优先调用的概率越大。不是一定优先运行。


阻塞的原因：
	IO等待
	sleep等方法睡眠等待
	线程运行获取某个有锁的对象，且锁未被释放
	线程在等待某个触发条件		

销毁状态
	run方法正常执行完成
	一个未捕获的异常终止了run方法而使线程猝死
	
isAlive方法，true表示可运行或者被阻塞，false表示销毁状态或者，刚刚被创建,新建状态
	

3、wait()与sleep()比较
相同点：都会使线程进入等待状态
不同点：
sleep()定义在Thread类
wait()定义在Object类
sleep() 暂停指定的时间，一段时间后自动恢复，不释放对象锁
wait() 不自动恢复，释放对象锁，需要靠notify()或notifyall()唤醒


4、停止线程
退出标志，run方法完成后，会正常退出线程
stop（）方法停止线程，不推荐使用
interrupt()中断线程

5、其他重要的线程方法
join()方法 ,让其他线程变为等待状态，
	t1.join();//让其他线程等待，直到t1执行完毕。
	常用例子，子线程执行完毕，主线程才能继续的场景

守护线程和用户线程
	一般用户定义新的线程，即用户线程，启动以后，与主线程没有关系，互不影响
	而使用setDaemon(true)设置为守护线程后，主线程结束，该守护线程也随之结束
	
Thread.yield()暂停当前正在执行的 线程，并执行其他线程,仅针对同一优先级，可能没有效果(可能再次被调度程序选中)。
		

6、手动获取和释放的锁，lock 
jdk1.5之后，才可使用



7、进程与线程的区别
进程是一个正在运行的程序，进程是所有线程的集合,进程可在任务管理器查看，线程不可以。
线程是cpu的执行最小单元。


8、多线程通讯，使用 join(),wait(),notify()

9、线程安全问题，即  多个线程同时对一个全局变量或静态变量经行写操作时，可能发生的数据冲突问题。


10、多线程三大特性
原子性 ，比如转账操作：A账户转入10000，B账户转出10000，要么都完成，要么都不完成。
有序性，线程A修改了共享变量x=1，线程B访问时共享变量x时值为1
可见性，安装代码先后顺序执行

11、多线程死锁
同步中嵌套同步。。应当避免这种情况出现

12、Java内存模型,简称jmm
Java内存是为了屏蔽物理CPU与CPU缓存与主内存之间缓存一致协议  从而实现跨平台提出的JAVA内存模型  
Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）来屏蔽掉各种硬件和操作系统的内存访问差异
，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，不必因为不同平台上的物理机的内存模型的差异
，对各平台定制化开发程序

Java 内存模型提出目标在于，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
此处的变量(Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变
量与方法参数，因为后者是线程私有的。
注：如果局部变量是一个 reference 类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部
变量表中，它是线程私有的。

共享变量x=6存放在主内存中，   现有A、B两个线程需要读共享变量x，两个线程都会存储该变量的副本到 
 各自 线程的私有本地内存（抽象概念）,A线程先写入值x=7到共享变量，这个时候变量x先存储在A线程私有本地内存中，
 然后刷入主内存。这个时候B来主内存读取变量x,默认读取的是线程B的本地内存，还是X=6。
 这个时候，就发生了线程安全问题。
 
 线程之间变量是不可见的，读取的是副本，没有及时读取主内存中的结果。
 
13、volatile
保证可见性
	线程对变量进行修改之后，要立刻回写到主内存。
	线程对变量读取的时候，要从主内存中读，而不是从线程的工作内存。
禁止进行指令重排序

举个例子：定义 volatile int count = 0，2 个线程同时执行 count++ 操作，每个线程都执行 500 次，最终结果小于 1000。
原因是每个线程执行 count++ 需要以下 3 个步骤：
	线程从主内存读取最新的 count 的值。
	执行引擎把 count 值加 1，并赋值给线程工作内存。
	线程工作内存把 count 值保存到主内存。


通过 synchronized 关键字包住的代码区域，对数据的读写进行控制：
	读数据，当线程进入到该区域读取变量信息时，对数据的读取也不能从工作内存读取，只能从内存中读取，保证读到的是最新的值。
	写数据，在同步区内对变量的写入操作，在离开同步区时就将当前线程内的数据刷新到内存中，保证更新的数据对其他线程的可见性。

14、volatile 与 synchronized 区别
volatile 只修饰变量， synchronized 修饰方法，变量等   （实际作用在对象或者class字节码）
volatile 只保证线程可见，但不会阻塞线程访问，所以不能保证数据同步，容易引起线程安全问题
synchronized 保证只有一个线程访问对象，其他线程会阻塞，可以保证数据同步(注意不要嵌套使用，会出现死锁)

15、AtomicInteger （Integer类） 提供线程安全的原子加减操作  



 
