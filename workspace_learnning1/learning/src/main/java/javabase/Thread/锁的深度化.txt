悲观锁、排他锁、乐观锁

多个请求同时操作数据库，将订单修改为已支付状态，金额加上2000，在同时并发场景下

悲观锁，悲观认为每一次操作都会造成数据丢失问题，在每次查询时加上排他锁
排他锁，
乐观锁，乐观认为每次查询不会出现数据丢失问题，利用版本字段控制


重入锁，也叫递归锁
java中，如synchronized ReentrantLock  都是这种类型的锁
指同一线程中，外层函数获得锁之后，函数内部的函数仍有获得该锁的代码，但不受影响
public class Test implements Runnable {
	public synchronized void get() {
		System.out.println("name:" + Thread.currentThread().getName() + " get();");
		set();
	}

	public synchronized void set() {
		System.out.println("name:" + Thread.currentThread().getName() + " set();");
	}

	@Override

	public void run() {
		get();
	}
	
读写锁
两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源
。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写
读-读能共存，读-写不能共存，写-写不能共存	
Java5在java.util.concurrent包中已经包含了读写锁


CAS无锁机制

1）与锁相比，使用比较交换（下文简称CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。
（2）无锁的好处：
第一，在高并发的情况下，它比有锁的程序拥有更好的性能；
第二，它天生就是死锁免疫的。
就凭借这两个优势，就值得我们冒险尝试使用无锁的并发。
（3）CAS算法的过程是这样：它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。
（4）CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。
（5）简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。
（6）在硬件层面，大部分的现代处理器都已经支持原子化的CAS指令。在JDK 5.0以后，虚拟机便可以使用这个指令来实现并发操作和并发数据结构，并且，这种操作在虚拟机中可以说是无处不在



自旋锁

自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区

分布式锁

如果想在不同的jvm中保证数据同步，使用分布式锁技术。
有数据库实现、缓存实现、Zookeeper分布式锁



